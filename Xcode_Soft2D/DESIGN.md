# 设计方针

平台层使用 SDL，仅作为窗口和 framebuffer 显示，不属于系统设计核心。

这不是游戏引擎，这只是个最小运行时。一个用于教学、研究、验证想法的最小2D运行时。名字只叫做Soft2D。

目标用户和过去的我一样：
- 想知道“游戏到底是怎么运行的”
- 不想被引擎吞掉
想做：
- 教学
- 可回放的2D模拟 


## 四个问题（此为宣言，而非文档。）
1. 这个系统解决什么问题？
2. 它刻意不解决什么问题？
3. 为什么用软件渲染？
4. 为什么 draw / platform 必须解耦？

解答：
1. 使用简单，上手快，源码少、可读，中文注释。
2. 软渲染，没硬件加速
3. ...
4. 为了跨平台、方便维护

## 第一阶段末尾四个问题
1. 如果机器很慢，会发生什么？
2. 如果 sleep 不准，漂移怎么累计？
3. fixed timestep 和 variable timestep 的取舍是什么？
4. 如果一帧太慢，我是跳帧、补算、还是接受？

解答：
1. 掉帧，视觉上的连贯性消失。物理穿模。
2. 误差累积，逻辑时钟落后于真实世界时钟，解决方案是追赶机制，对比真实时间如果发现落后了就停止sleep，连续运行逻辑进行追赶直到追平。
3. 目前使用Variable timestep，简单直观，任何FPS下都平滑，物理模拟不稳定，delta波动会导致浮点数四舍五入误差，难以回放（Replay）以及同步联机，但是做单机小游戏够用了。Fixed 物理模拟结果确定，逻辑与渲染解耦，但是处理不好会卡，需要处理余数时间的差值。
4. 一帧太慢，如果接受，物体会瞬移。如果补算，在此期间用时很久，下一帧更慢，然后你又要算，程序就卡死了。如果跳帧，给delta time一个上限，游戏会变成慢动作，但是保证物理世界不崩溃，最稳妥。

**该引擎优先考虑模拟稳定性，而不是实时准确性。**

Fix Your Timestep (By Glenn Fiedler)
大致逻辑如下：
```c++
double t = 0.0;
double dt = 0.01; // 固定的逻辑步长（如 100Hz）
double accumulator = 0.0; // 时间累加器

// 在主循环中
double frameTime = GetRealDeltaTime(); // 获取真实的物理时间差
if (frameTime > 0.25) frameTime = 0.25; // 限制上限，防止死亡螺旋
accumulator += frameTime;

while (accumulator >= dt) {
    Integrate(t, dt); // 运行固定的物理逻辑
    t += dt;
    accumulator -= dt;
}

const double alpha = accumulator / dt;
Render(alpha); // 使用 alpha 进行插值平滑画面
```

## 必须循守的法则
一旦破坏，整个系统就会失效！

- 单一时间源+固定步进
- 输入是数据，不是事件
- 随机性必须是显式的
- 渲染永远是状态的纯函数
